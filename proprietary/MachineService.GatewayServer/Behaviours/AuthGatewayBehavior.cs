// Copyright (c) 2025 Duplicati Inc. All rights reserved.

using MachineService.Common;
using MachineService.Common.Enums;
using MachineService.Common.Exceptions;
using MachineService.Common.Interfaces;
using MachineService.Common.Model;
using MachineService.Common.Services;
using MachineService.Common.Util;
using MachineService.State.Interfaces;
using Serilog;
using WebSockets.Common;
using WebSockets.Common.Model;

namespace MachineService.GatewayServer.Behaviours;

/// <summary>
/// Behavior for handling authentication messages from Portal clients
/// </summary>
/// <param name="envConfig">The environment configuration</param>
/// <param name="derivedConfig">The derived configuration</param>
/// <param name="stateManagerService">The state manager service</param>
/// <param name="backendRelayConnection">The backend relay connection service</param>
/// <param name="statisticsGatherer">The statistics gatherer service</param>
public class AuthGatewayBehavior(
    EnvironmentConfig envConfig,
    DerivedConfig derivedConfig,
    IStateManagerService stateManagerService,
    IStatisticsGatherer statisticsGatherer) : IMessageBehavior
{
    /// <summary>
    /// The command this behavior handles
    /// </summary>
    public static string Command => MessageTypes.AuthGateway.ToString().ToLowerInvariant();

    /// <inheritdoc />
    public async Task ExecuteAsync(SocketState state, EnvelopedMessage message)
    {
        Log.Debug("Authenticating gateway {ClientId}", message.From);

        if (string.IsNullOrWhiteSpace(message.Payload))
            throw new PolicyViolationException(ErrorMessages.AuthMessageWithoutPayload);

        // We only accept authgateway from clients originally identified as Gateway
        // via the route on the connection, who would be in the following states
        // The reason we allow Authenticated to call it again, is to allow easy an
        // way to keep a connection by simply authenticating again in the same socket.
        switch (state.ConnectionState)
        {
            case ConnectionState.ConnectedGatewayUnauthenticated:
            case ConnectionState.ConnectedGatewayAuthenticated:
                break;
            default:
                throw new PolicyViolationException(ErrorMessages.InvalidConnectionStateForAuthentication);
        }

        AuthGatewayMessage authRequest;
        try
        {
            authRequest = message.DeserializePayload<AuthGatewayMessage>() ?? throw new InvalidOperationException();
        }
        catch (Exception)
        {
            throw new PolicyViolationException(ErrorMessages.InvalidAuthPayload);
        }

        if (string.IsNullOrWhiteSpace(authRequest?.Hash) || string.IsNullOrWhiteSpace(authRequest.Nonce))
            throw new PolicyViolationException(ErrorMessages.AuthMessageWithoutToken);

        // Validate the hash, using the PSK, the initial hash generated by the gateway, and the nonce provided by the caller
        var expectedHash = AuthHandshake.CreateThreePartHash(envConfig.GatewayPreSharedKey!, state.NonceBytes!, Convert.FromBase64String(authRequest.Nonce));
        if (expectedHash != authRequest.Hash)
        {
            state.ConnectionState = ConnectionState.ConnectedGatewayUnauthenticated;
            statisticsGatherer.Increment(StatisticsType.AuthGatewayFailure);
            throw new PolicyViolationException(ErrorMessages.IncorrectGatewayHandshake);
        }

        // We now consider the caller authenticated
        state.ClientId = message.From!;
        state.ConnectionState = ConnectionState.ConnectedGatewayAuthenticated;

        await stateManagerService.RegisterClient(state.Type, state.ConnectionId, state.ClientId, state.OrganizationId!,
            state.RegisteredAgentId, state.ClientVersion, envConfig.InstanceId, state.RemoteIpAddress, CancellationToken.None);

        // Create a response hash, using the PSK, the hash provided by the caller, and the nonce provided by the caller
        // The caller can now verify that we know the PSK as well
        var responseHash = AuthHandshake.CreateThreePartHash(envConfig.GatewayPreSharedKey!, Convert.FromBase64String(authRequest.Hash), Convert.FromBase64String(authRequest.Nonce));
        var response = new EnvelopedMessage
        {
            Type = MessageTypes.AuthGateway.ToString().ToLowerInvariant(),
            From = envConfig.InstanceId,
            MessageId = Guid.NewGuid().ToString(),
            To = message.From,
            Payload = EnvelopedMessage.SerializePayload(new AuthGatewayMessage(
                null,
                responseHash
            ))
        };

        // For authgateway, it can only be sent in plaintext.
        await state.WriteMessage(response, WrappingType.PlainText, derivedConfig.PrivateKey);

        Log.Debug("Authenticated gateway {From}, {ClientId} - Success.", message.From, state.ClientId);

        statisticsGatherer.Increment(StatisticsType.AuthGatewaySuccess);
    }
}